# 练习2. 使用GDB验证启动流程

**调试过程以及观察结果**：

首先我们进入实验代码文件，使用`make debug`启动`qemu`调试服务器，然后再打开一个终端使用`make gdb`进行调试，接着输入指令 `x/10i $pc `查看即将执行的10条汇编指令，根据输出可以知道`RISC-V`硬件加电后最初执行的几条指令位于地址`0x1000`附近，在`0x1014` 的指令处会发生跳转，因此实际执行的指令如下所示：

```assembly
0x1000:	 auipc	t0,0x0         # t0 = PC + (0x0 << 12) = 0x1000
0x1004:	 addi	a1,t0,32       # a1 = t0 + 32 = 0x1020
0x1008:	 csrr	a0,mhartid     # a0 = mhartid = 0
0x100c:	 ld	    t0,24(t0)      # t0 = [t0 + 24] = 0x80000000
0x1010:	 jr	    t0             # 跳转到地址0x80000000
```

然后我们使用`si`进行单步执行，使用`info r t0`类指令查看上述指令执行情况：

```assembly
(gdb) si
0x0000000000001004 in ?? ()
(gdb) info r t0
t0             0x1000	4096               #观察到t0值为0x1000
(gdb) si
0x0000000080000000 in ?? ()
(gdb) info r a1
a1             0x1020	4128               #观察到a1值为1020
(gdb) si
0x0000000080000004 in ?? ()
(gdb) info r a0
a0             0x0	0                      #观察到a0值为0
(gdb) si
0x0000000000001010 in ?? ()
(gdb) info r t0
t0             0x80000000	2147483648    #观察到t0变为0x80000000，即跳转目标
(gdb) si
0x0000000080000000 in ?? ()               #执行跳转到OpenSBI
```

根据上述内容可知，该部分属于硬件固件层，`CPU`加电后`PC`寄存器被硬编码到`0x1000`，然后后续指令进行最基础的硬件初始化，最后跳转到`OpenSBI`进入`bootloader`层，进行开机并且加载`OS`到内存里。

接下来我们输入`x/10i 0x80000000`，用来显示`0x80000000`处的10条指令，该处是`OpenSBI`的标准位置，作用为加载操作系统内核并启动操作系统的执行，运行结果如下所示：

```assembly
0x80000000: csrr  a6,mhartid         # a6 = mhartid (获取当前CPU核心ID)
0x80000004: bgtz  a6,0x80000108      # 如果 a6 > 0，则跳转到0x80000108
0x80000008: auipc t0,0x0             # t0 = pc + (0x0 << 12) = 0x80000008
0x8000000c: addi  t0,t0,1032         # t0 = t0 + 1032 = 0x80000408
0x80000010: auipc t1,0x0             # t1 = pc + (0x0 << 12) = 0x80000010
0x80000014: addi  t1,t1,-16          # t1 = t1 - 16 = 0x80000000
0x80000018: sd    t1,0(t0)           # 将t1的值存储在t0（地址0x80000408）处
0x8000001c: auipc t0,0x0             # t0 = pc + (0x0 << 12) = 0x8000001c
0x80000020: addi  t0,t0,1020         # t0 = t0 + 1020 = 0x80000400
0x80000024: ld    t0,0(t0)           # 从地址0x80000400加载一个双字到t0
```

根据结果，我们可以看到首先进行区分主核心（核心0）和其他核心，只有核心0继续执行初始化，其他核心等待或执行特定任务，然后进行了运行环境的一些配置。

接下来我们分析内核启动执行，我们使用`b* kern_entry`直接对`kern_entry`函数下断点，内核会运行到我们设置好的断点处停止，然后运行`c`，输出结果如下：

```
Breakpoint 1, kern_entry () at kern/init/entry.S:7
7	    la sp, bootstacktop
```

然后我们去查看`kern/init/entry.S`的内容，发现此时内核暂停在入口函数的第一条汇编指令处，为`la sp, bootstacktop `，表示将`bootstacktop` 的地址赋给 `sp `，作为栈。并且debug界面输出了如下相关信息，说明`OpenSBI`已经启动。
<img width="713" height="572" alt="d513b341f0b56fc286ee2068c3892273" src="https://github.com/user-attachments/assets/ebad77f7-bdf7-463d-a32c-63995c3b256c" />

接着我们输入指令 `x/5i 0x80200000` ，查看入口函数附件的汇编代码：

```assembly
0x80200000 <kern_entry>:    auipc   sp,0x3  #将当前PC值加上0x3000，结果存入sp寄存器
0x80200004 <kern_entry+4>:  mv      sp,sp
0x80200008 <kern_entry+8>:  j       0x8020000a <kern_init> #无条件跳转到kern_init函数
0x8020000a <kern_init>:     auipc   a0,0x3
0x8020000e <kern_init+4>:   addi    a0,a0,-2
```

上述内容表明了内核确实加载到0x80200000，从 `0x80200000` 正确开始执行，并且`kern_entry`之后就是`kern_init`，即“真正的”内核入口点。接着我们继续运行，输入`x/20i kern_init`来查看`kern_init`附近的汇编指令，输出结果如下：

```assembly
0x8020000a <kern_init>:        auipc   a0,0x3
0x8020000e <kern_init+4>:      addi    a0,a0,-2
0x80200012 <kern_init+8>:      auipc   a2,0x3
0x80200016 <kern_init+12>:     addi    a2,a2,-10
0x8020001a <kern_init+16>:     addi    sp,sp,-16
0x8020001c <kern_init+18>:     li      a1,0
0x8020001e <kern_init+20>:     sub     a2,a2,a0
0x80200020 <kern_init+22>:     sd      ra,8(sp)
0x80200022 <kern_init+24>:     jal     0x80200490 <memset>
0x80200026 <kern_init+28>:     auipc   a1,0x0
0x8020002a <kern_init+32>:     addi    a1,a1,1154
0x8020002e <kern_init+36>:     auipc   a0,0x0
0x80200032 <kern_init+40>:     addi    a0,a0,1178
0x80200036 <kern_init+44>:     jal     0x80200054 <cprintf>
0x8020003a <kern_init+48>:     j       0x8020003a <kern_init+48>
0x8020003c <cputch>:           addi    sp,sp,-32
0x8020003e <cputch+2>:         sd      ra,24(sp)
0x80200040 <cputch+4>:         sd      a1,8(sp)
0x80200042 <cputch+6>:         jal     0x80200088 <cons_putc>
0x80200046 <cputch+10>:        ld      a1,8(sp)
```

我们发现在第14条指令处跳转到了`cprintf`函数里，这是用来输出相关信息，并且观察到第15行内容是`0x8020003a <kern_init+48>:   j   0x8020003a <kern_init+48>`，表示跳转到自己，因此代码会在此循环运行下去。我们输入`c`继续运行，发现`debug`终端窗口有如下输出：

```assembly
(THU.CST) os is loading ...
```

这表示我们所有环节都正确工作了，说明我们完整跟踪了从复位到内核输出的整个流程。

**练习2问题答案：**

1.`RISC-V`硬件加电后最初执行的几条指令位于地址`0x1000`到`0x1010`处。

2.最初执行的几条指令：

+ `auipc t0,0x0`：计算当前PC相关的地址，将 `0x1000` 存入`t0`寄存器作为基地址。
+ `addi a1,t0,32`：将`t0`加上`32`，赋值给`a1`。
+ `csrr a0,mhartid`：读取`mhartid`（当前`CPU`核心的`ID`），存入`a0`中。
+ `ld t0,24(t0)`：从内存 `0x1018` 处加载`OpenSBI`的入口地址到`t0`。
+ `jr t0`：跳转到`OpenSBI`的入口地址 `0x80000000`。

完成的主要功能是获取当前`CPU`核心`ID`，准备启动参数，并且按照`RISC-V`调用约定设置参数，然后读取到`OenSBI`入口地址，跳转到其地址来执行`OpenSBI`。
