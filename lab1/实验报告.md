## 实验重要知识点
### 1. 启动流程 (Bootstrapping)

#### 实验中的知识点:

* **QEMU启动与硬件复位**: 
    > 实验中CPU从复位地址 `0x1000` 开始执行，然后跳转到 `0x80000000` 的 **OpenSBI固件**。这模拟了真实硬件加电后执行固化代码的过程。
* **Bootloader (OpenSBI)**: 
    > OpenSBI作为“先锋队”，负责初始化基本硬件环境，并将内核镜像从“硬盘”（由QEMU模拟加载）加载到物理内存的指定地址 **`0x80200000`**。
* **控制权移交**: 
    > OpenSBI完成任务后，通过跳转指令将CPU的控制权交给内核的入口点 (**`kern_entry` at `0x80200000`**)，之后内核开始独立运行。

#### 对应的OS原理知识点:

* **操作系统引导 (Operating System Booting)**: 
    > 这是OS原理中的经典概念，描述了计算机从加电状态到操作系统完全接管控制权的全过程。这个过程必须依赖固件（Firmware），因为操作系统自身无法将自己加载到内存中。

#### 理解与分析:

**含义**: 
实验中的启动流程是OS原理中“引导过程”的一个具体实例。它通过QEMU和OpenSBI，在RISC-V平台上实现了从固件到内核的“接力”。

**关系**: 
实验是原理的实践。原理课上讲解的 **“BIOS/UEFI -> Bootloader -> OS”模型**，在实验中被具体化为 **“QEMU复位代码 -> OpenSBI -> ucore内核”** 的三级跳。二者在分层、分工协作的核心思想上完全一致。

**差异**:
* **复杂性**: 真实的PC启动流程远比实验复杂，涉及大量的硬件自检（POST）、设备驱动加载和安全检查（如Secure Boot）。实验环境大大简化了这一过程，让我们能聚焦于核心的加载与跳转逻辑。
* **Bootloader角色**: 在实验中，内核镜像的加载地址 `0x80200000` 是在QEMU启动时通过参数直接指定的，OpenSBI更侧重于提供运行时服务（SBI服务）。而在真实的PC上，Bootloader（如GRUB）需要具备文件系统解析能力，去硬盘上查找并读取内核文件。

---

### 2. 内存布局与链接脚本

#### 实验中的知识点:

* **程序分段**: 
    > 实验代码被人为地划分为代码段( `.text` )、只读数据段( `.rodata` )、已初始化数据段( `.data` )和未初始化数据段( `.bss` )等。
* **链接脚本 (`kernel.ld`)**: 
    > 通过编写链接脚本，我们精确地控制了各个段在最终生成的可执行文件中的位置，并指定了整个内核的基地址为 **`0x80200000`**。特别地，我们确保了入口代码 `kern_entry` 位于文件的最前端。
* **地址相关性**: 
    > 实验强调了内核代码是地址相关的，即代码在编译链接时其内存地址就已经确定，因此必须被加载到链接脚本中指定的地址（`0x80200000`）才能正确运行。

#### 对应的OS原理知识点:

* **程序内存映像 (Process Memory Image)**: 
    > OS原理讲解了可执行程序在内存中的标准布局，包括代码区、数据区、BSS区、堆和栈等。这是操作系统管理和加载程序的基础。
* **链接与加载 (Linking and Loading)**: 
    > 原理课会介绍编译器、链接器和加载器如何协同工作，将源代码一步步转换为内存中可执行的指令。链接器负责解析符号、合并目标文件，并确定最终的内存布局。

#### 理解与分析:

**含义**: 
实验中的链接脚本是实现OS原理中“内存映像”概念的工具。它是一份“蓝图”，指导链接器 `ld` 如何构建内核这个特殊的“程序”。

**关系**: 
实验通过手动编写 `kernel.ld`，让我们深入实践了OS原理中的链接过程。我们不再像开发普通应用程序一样依赖默认链接脚本，而是作为内核设计者，主动规划内存的每一个区域。

**差异**:
* **目标不同**: 普通应用程序的链接是为了在一个已有的操作系统之上运行，而内核链接的目标是生成一个能独立运行、自给自足的程序。
* **.BSS段的处理**: 在 `kern_init` 函数中，有一段 `memset(edata, 0, end - edata);` 的代码。这正是对 `.bss` 段的手动清零操作。普通应用程序的 `.bss` 段是由操作系统加载器在加载时清零的，而我们的内核必须“自己动手”完成这个工作，因为它没有更底层的加载器为它服务了。

---

### 3. 特权级与SBI服务

#### 实验中的知识点:

* **RISC-V特权级**: 
    > 实验明确指出了RISC-V的 **`M-Mode`**（机器态）和 **`S-Mode`**（监督态）。OpenSBI运行在权限最高的 `M-Mode`，而我们的内核运行在 `S-Mode`。
* **`ecall` 指令**: 
    > 内核（`S-Mode`）无法直接执行某些底层操作，必须通过 `ecall` 指令陷入（trap）到 `M-Mode`，请求OpenSBI提供服务。
* **SBI调用封装**: 
    > 实验中我们通过内联汇编将 `ecall` 的调用过程封装成C函数 `sbi_call`，并在此基础上层层封装，最终实现了类似标准库的 `cprintf` 函数。

#### 对应的OS原理知识点:

* **CPU特权级与保护 (Privilege Levels & Protection)**: 
    > 这是现代OS的基石。通过划分特权级，可以保护内核免受用户程序的破坏，并对硬件访问进行仲裁。
* **系统调用 (System Call)**: 
    > OS原理的核心内容之一。应用程序（用户态）通过陷入（trap）机制向操作系统（内核态）请求服务，这是应用程序与内核交互的唯一规范途径。

#### 理解与分析:

**含义**: 
实验中 `S-Mode` 通过 `ecall` 调用 `M-Mode` 的SBI服务，是OS原理中“系统调用”思想在更底层硬件与固件之间的体现。

**关系**: 
二者在机制上高度相似。都是通过一个受控的、预定义接口（SBI调用约定 vs 系统调用ABI），从低特权级向高特权级请求服务。实验中的 `sbi_call` 函数，就是对这种底层“陷入”机制的C语言封装，与标准库（如glibc）封装系统调用的做法如出一辙。

**差异**:
* **服务提供者**: 在实验的 `cprintf` 实现中，服务的提供者是 **OpenSBI固件**；而在OS原理的系统调用中，服务的提供者是 **操作系统内核**。
* **发生场景**: 实验中的 `ecall` 发生在 `S-Mode` 到 `M-Mode` 之间，是为了让内核获得底层的硬件服务；而传统意义上的系统调用发生在 `U-Mode` 到 `S-Mode` 之间，是为了让应用程序获得文件、网络等操作系统服务。

## 实验未提到的知识点
实验仅操作物理地址，未涉及：
### 页面置换算法:

#### 最优页面置换算法
- 基本思路:置换在未来最长时间不访问的页面
- 实现:缺页时，计算内存中每个逻辑页面的下一次访问时间;
  选择未来最长时间不访问的页面;

#### 先进先出算法
- 基本思路:选择在内存驻留时间最长的页面进行置换
- 实现:维护一个记录所有位于内存中的逻辑页面链表;
  链表元素按驻留内存的时间排序，链首最长，链尾最短;
  出现缺页时，选择链首页面进行置换，新页面加到链尾;


### 缺页异常处理:
- CPU发出访存指令到MMU，MMU根据地址高位部分得到页号，以页号查页表；
- 查表发现该页表项未填入有效值，因此产生缺页异常
- 缺页异常由OS响应，OS需要分配对应的页帧，并找到该页的内容在磁盘中的位置；
- 找到系统中的空闲页帧，从磁盘中读取相应的数据填入页帧中；
- 将页帧号填入页表中，并修改页表的有效位；
- 异常返回，重新执行产生缺页的指令


## 练习1. 

### la sp, bootstacktop的作用:
- ‌加载栈指针‌：该指令将符号bootstacktop的地址加载到栈指针寄存器sp中，其中bootstacktop是通过.align PGSHIFT对齐的内核栈顶部地址。这为内核初始化过程建立了可用的调用栈空间。
- ‌栈空间初始化‌：bootstack区域通过.space KSTACKSIZE预留了固定大小的内核栈空间，bootstacktop标识其顶部。此操作确保内核在保护模式切换前已具备执行函数调用的基础环境。
### tail kern_init的作用:
- 跳转至内核初始化‌：tail指令实现尾调用优化，直接跳转到kern_init函数而不保留返回地址。这避免了不必要的栈帧保存，同时将控制权转移给内核的主初始化逻辑。
- ‌启动流程衔接‌：在完成基础硬件初始化后，该指令标志着内核从汇编引导阶段进入C语言实现的核心初始化阶段。


## 练习2. 使用GDB验证启动流程

  

**调试过程以及观察结果**：

  

首先我们进入实验代码文件，使用`make debug`启动`qemu`调试服务器，然后再打开一个终端使用`make gdb`进行调试，接着输入指令 `x/10i $pc `查看即将执行的10条汇编指令，根据输出可以知道`RISC-V`硬件加电后最初执行的几条指令位于地址`0x1000`附近，在`0x1014` 的指令处会发生跳转，因此实际执行的指令如下所示：

  

```assembly

0x1000:     auipc   t0,0x0        #t0 = PC + (0x0 << 12) = 0x1000

0x1004:     addi    a2,t0,40      #a2 = t0 + 40 = 0x1028

0x1008:     csrr    a0,mhartid    #a0 = mhartid 的值

0x100c:     ld      a1,32(t0)     #a1 = memory[t0 + 32] = memory[0x1020]

0x1010:     ld      t0,24(t0)     #t0 = memory[t0 + 24] = memory[0x1018]

0x1014:     jr      t0            #PC = t0 = 0x80000000

```

  

然后我们使用`si`进行单步执行，使用`info r t0`类指令查看上述指令执行情况：

  

```assembly

(gdb) si

0x0000000000001004 in ?? ()

(gdb) info r t0

t0             0x1000   4096               #观察到t0值为0x1000

(gdb) si

0x0000000000001008 in ?? ()

(gdb) info r a2

a2             0x1028   4136               #观察到a2值为0x1028

(gdb) si

0x000000000000100c in ?? ()

(gdb) info r a0

a0             0x0  0                      #观察到a0值为0（因为mhartid就是0）

(gdb) si

0x0000000000001010 in ?? ()

(gdb) info r a1

a1             0x87e00000   2279604224     #观察到a1从内存加载的值

(gdb) si

0x0000000000001014 in ?? ()

(gdb) info r t0

t0             0x80000000   2147483648     #观察到t0变为0x80000000，即跳转目标

(gdb) si

0x0000000080000000 in ?? ()                #执行跳转到OpenSBI

```

  

根据上述内容可知，该部分属于硬件固件层，`CPU`加电后`PC`寄存器被硬编码到`0x1000`，然后后续指令进行最基础的硬件初始化，最后跳转到`OpenSBI`进入`bootloader`层，进行开机并且加载`OS`到内存里。

  

接下来我们输入`x/10i 0x80000000`，用来显示`0x80000000`处的10条指令，该处是`OpenSBI`的标准位置，作用为加载操作系统内核并启动操作系统的执行，运行结果如下所示：

  

```assembly

0x80000000: add    s0, a0, zero    # s0 = a0 (保存第一个参数)

0x80000004: add    s1, a1, zero    # s1 = a1 (保存第二个参数)  

0x80000008: add    s2, a2, zero    # s2 = a2 (保存第三个参数)

0x8000000c: jal    0x80000580      # 跳转到OpenSBI主初始化函数

0x80000010: add    a6, a0, zero    # a6 = 返回值 (从初始化函数返回)

0x80000014: add    a0, s0, zero    # 恢复原始参数 a0 = s0

0x80000018: add    a1, s1, zero    # 恢复原始参数 a1 = s1

0x8000001c: add    a2, s2, zero    # 恢复原始参数 a2 = s2

0x80000020: li     a7, -1          # a7 = -1 (可能表示某种标志)

0x80000022: beq    a6, a7, 0x8000002a  # 如果a6 == -1，跳转到0x8000002a

```

  

根据结果，我们可以看到首先进行了参数准备，然后进行主初始化并在主初始化内部进行内核加载，于是我们使用`watch *0x80200000`观察内核加载瞬间，避免单步跟踪大量代码，但是我们发现`watchpoint`未触发，通过检查得到内核已经位于`0x80200000`，造成这种现象可能是由于内核加载过程发生在我们设置`watchpoint`之前。

  

接下来我们分析内核启动执行，我们可以使用`b* kern_entry`直接对`kern_entry`函数下断点，随后执行`continue`(缩写为`c`)开始执行程序，内核会在运行到我们设置好的断点处停止，输出结果如下：

  

```

Breakpoint 1, kern_entry () at kern/init/entry.S:7

7           la sp, bootstacktop

```

  

此时内核暂停在入口函数的第一条汇编指令处，为`la sp, bootstacktop `，表示将`bootstacktop` 的地址赋给 `sp `，作为栈。接着我们输入指令 `x/5i 0x80200000` ，查看入口函数附件的汇编代码：

  

```assembly

0x80200000 <kern_entry>:    auipc   sp,0x3  #将当前PC值加上0x3000，结果存入sp寄存器

0x80200004 <kern_entry+4>:  mv      sp,sp

0x80200008 <kern_entry+8>:  j       0x8020000a <kern_init> #无条件跳转到kern_init函数

0x8020000a <kern_init>:     auipc   a0,0x3

0x8020000e <kern_init+4>:   addi    a0,a0,-2

```

  

上述内容表明`kern_entry`之后就是`kern_init`，即“真正的”内核入口点，我们运行`b* kern_init`，在`kern_init`处设置断点，输出结果如下：

  

```assembly

Breakpoint 2 at 0x8020000a: file kern/init/init.c, line 8.

```

  

接着我们继续运行，输入`x/20i kern_init`来查看`kern_init`附近的汇编指令，输出结果如下：

  

```assembly

0x8020000a <kern_init>:        auipc   a0,0x3

0x8020000e <kern_init+4>:      addi    a0,a0,-2

0x80200012 <kern_init+8>:      auipc   a2,0x3

0x80200016 <kern_init+12>:     addi    a2,a2,-10

0x8020001a <kern_init+16>:     addi    sp,sp,-16

0x8020001c <kern_init+18>:     li      a1,0

0x8020001e <kern_init+20>:     sub     a2,a2,a0

0x80200020 <kern_init+22>:     sd      ra,8(sp)

0x80200022 <kern_init+24>:     jal     0x80200490 <memset>

0x80200026 <kern_init+28>:     auipc   a1,0x0

0x8020002a <kern_init+32>:     addi    a1,a1,1154

0x8020002e <kern_init+36>:     auipc   a0,0x0

0x80200032 <kern_init+40>:     addi    a0,a0,1178

0x80200036 <kern_init+44>:     jal     0x80200054 <cprintf>

0x8020003a <kern_init+48>:     j       0x8020003a <kern_init+48>

0x8020003c <cputch>:           addi    sp,sp,-32

0x8020003e <cputch+2>:         sd      ra,24(sp)

0x80200040 <cputch+4>:         sd      a1,8(sp)

0x80200042 <cputch+6>:         jal     0x80200088 <cons_putc>

0x80200046 <cputch+10>:        ld      a1,8(sp)

```

  

我们发现在第14条指令处跳转到了`cprintf`函数里，这是用来输出相关信息，并且观察到第15行内容是`0x8020003a <kern_init+48>:   j   0x8020003a <kern_init+48>`，表示跳转到自己，因此代码会在此循环运行下去。我们输入`c`继续运行，发现`debug`终端窗口有如下输出：

  

```assembly

(THU.CST) os is loading ...

```

  

这表示链接脚本正确将内核加载到`0x80200000`处，内核已经成功从`OpenSBI`处接管控制权。

  

**练习2问题答案：**

  

1.`RISC-V`硬件加电后最初执行的几条指令位于地址`0x1000`到`0x1014`处。

  

2.最初执行的几条指令：

  

+ `auipc t0,0x0`：计算当前PC相关的地址，将 `0x1000` 存入`t0`寄存器作为基地址。

  

+ `addi a1,t0,32`：将`t0`加上`32`，赋值给`a1`。

  

+ `csrr a0,mhartid`：读取`mhartid`（当前`CPU`核心的`ID`），存入`a0`中。

  

+ `ld a1,32(t0)`：从内存 `0x1020` 处加载一个值到`a1`。

  

+ `ld t0,24(t0)`：从内存 `0x1018` 处加载`OpenSBI`的入口地址到`t0`。

  

+ `jr t0`：跳转到`OpenSBI`的入口地址 `0x80000000`。

  

完成的主要功能是获取当前`CPU`核心`ID`，准备启动参数，并且按照`RISC-V`调用约定设置参数，然后读取到`OenSBI`入口地址，跳转到其地址来执行`OpenSBI`。****