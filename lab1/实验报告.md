
# 练习2. 使用GDB验证启动流程

**调试过程以及观察结果**：

首先我们进入实验代码文件，使用`make debug`启动`qemu`调试服务器，然后再打开一个终端使用`make gdb`进行调试，接着输入指令 `x/10i $pc `查看即将执行的10条汇编指令，根据输出可以知道`RISC-V`硬件加电后最初执行的几条指令位于地址`0x1000`附近，在`0x1014` 的指令处会发生跳转，因此实际执行的指令如下所示：

```assembly
0x1000:	    auipc	t0,0x0        #t0 = PC + (0x0 << 12) = 0x1000
0x1004:	    addi	a2,t0,40      #a2 = t0 + 40 = 0x1028
0x1008:	    csrr	a0,mhartid    #a0 = mhartid 的值
0x100c:	    ld	    a1,32(t0)     #a1 = memory[t0 + 32] = memory[0x1020]
0x1010:	    ld	    t0,24(t0)     #t0 = memory[t0 + 24] = memory[0x1018]
0x1014:	    jr	    t0            #PC = t0 = 0x80000000
```

然后我们使用`si`进行单步执行，使用`info r t0`类指令查看上述指令执行情况：

```assembly
(gdb) si
0x0000000000001004 in ?? ()
(gdb) info r t0
t0             0x1000	4096               #观察到t0值为0x1000
(gdb) si
0x0000000000001008 in ?? ()
(gdb) info r a2
a2             0x1028	4136               #观察到a2值为0x1028
(gdb) si
0x000000000000100c in ?? ()
(gdb) info r a0
a0             0x0	0                      #观察到a0值为0（因为mhartid就是0）
(gdb) si
0x0000000000001010 in ?? ()
(gdb) info r a1
a1             0x87e00000	2279604224     #观察到a1从内存加载的值
(gdb) si
0x0000000000001014 in ?? ()
(gdb) info r t0
t0             0x80000000	2147483648     #观察到t0变为0x80000000，即跳转目标
(gdb) si
0x0000000080000000 in ?? ()                #执行跳转到OpenSBI
```

根据上述内容可知，该部分属于硬件固件层，`CPU`加电后`PC`寄存器被硬编码到`0x1000`，然后后续指令进行最基础的硬件初始化，最后跳转到`OpenSBI`进入`bootloader`层，进行开机并且加载`OS`到内存里。

接下来我们输入`x/10i 0x80000000`，用来显示`0x80000000`处的10条指令，该处是`OpenSBI`的标准位置，作用为加载操作系统内核并启动操作系统的执行，运行结果如下所示：

```assembly
0x80000000: add    s0, a0, zero    # s0 = a0 (保存第一个参数)
0x80000004: add    s1, a1, zero    # s1 = a1 (保存第二个参数)  
0x80000008: add    s2, a2, zero    # s2 = a2 (保存第三个参数)
0x8000000c: jal    0x80000580      # 跳转到OpenSBI主初始化函数
0x80000010: add    a6, a0, zero    # a6 = 返回值 (从初始化函数返回)
0x80000014: add    a0, s0, zero    # 恢复原始参数 a0 = s0
0x80000018: add    a1, s1, zero    # 恢复原始参数 a1 = s1
0x8000001c: add    a2, s2, zero    # 恢复原始参数 a2 = s2
0x80000020: li     a7, -1          # a7 = -1 (可能表示某种标志)
0x80000022: beq    a6, a7, 0x8000002a  # 如果a6 == -1，跳转到0x8000002a
```

根据结果，我们可以看到首先进行了参数准备，然后进行主初始化并在主初始化内部进行内核加载，于是我们使用`watch *0x80200000`观察内核加载瞬间，避免单步跟踪大量代码，但是我们发现`watchpoint`未触发，通过检查得到内核已经位于`0x80200000`，造成这种现象可能是由于内核加载过程发生在我们设置`watchpoint`之前。

接下来我们分析内核启动执行，我们可以使用`b* kern_entry`直接对`kern_entry`函数下断点，随后执行`continue`(缩写为`c`)开始执行程序，内核会在运行到我们设置好的断点处停止，输出结果如下：

```
Breakpoint 1, kern_entry () at kern/init/entry.S:7
7           la sp, bootstacktop
```

此时内核暂停在入口函数的第一条汇编指令处，为`la sp, bootstacktop `，表示将`bootstacktop` 的地址赋给 `sp `，作为栈。接着我们输入指令 `x/5i 0x80200000` ，查看入口函数附件的汇编代码：

```assembly
0x80200000 <kern_entry>:    auipc   sp,0x3  #将当前PC值加上0x3000，结果存入sp寄存器
0x80200004 <kern_entry+4>:  mv      sp,sp
0x80200008 <kern_entry+8>:  j       0x8020000a <kern_init> #无条件跳转到kern_init函数
0x8020000a <kern_init>:     auipc   a0,0x3
0x8020000e <kern_init+4>:   addi    a0,a0,-2
```

上述内容表明`kern_entry`之后就是`kern_init`，即“真正的”内核入口点，我们运行`b* kern_init`，在`kern_init`处设置断点，输出结果如下：

```assembly
Breakpoint 2 at 0x8020000a: file kern/init/init.c, line 8.
```

接着我们继续运行，输入`x/20i kern_init`来查看`kern_init`附近的汇编指令，输出结果如下：

```assembly
0x8020000a <kern_init>:        auipc   a0,0x3
0x8020000e <kern_init+4>:      addi    a0,a0,-2
0x80200012 <kern_init+8>:      auipc   a2,0x3
0x80200016 <kern_init+12>:     addi    a2,a2,-10
0x8020001a <kern_init+16>:     addi    sp,sp,-16
0x8020001c <kern_init+18>:     li      a1,0
0x8020001e <kern_init+20>:     sub     a2,a2,a0
0x80200020 <kern_init+22>:     sd      ra,8(sp)
0x80200022 <kern_init+24>:     jal     0x80200490 <memset>
0x80200026 <kern_init+28>:     auipc   a1,0x0
0x8020002a <kern_init+32>:     addi    a1,a1,1154
0x8020002e <kern_init+36>:     auipc   a0,0x0
0x80200032 <kern_init+40>:     addi    a0,a0,1178
0x80200036 <kern_init+44>:     jal     0x80200054 <cprintf>
0x8020003a <kern_init+48>:     j       0x8020003a <kern_init+48>
0x8020003c <cputch>:           addi    sp,sp,-32
0x8020003e <cputch+2>:         sd      ra,24(sp)
0x80200040 <cputch+4>:         sd      a1,8(sp)
0x80200042 <cputch+6>:         jal     0x80200088 <cons_putc>
0x80200046 <cputch+10>:        ld      a1,8(sp)
```

我们发现在第14条指令处跳转到了`cprintf`函数里，这是用来输出相关信息，并且观察到第15行内容是`0x8020003a <kern_init+48>:   j   0x8020003a <kern_init+48>`，表示跳转到自己，因此代码会在此循环运行下去。我们输入`c`继续运行，发现`debug`终端窗口有如下输出：

```assembly
(THU.CST) os is loading ...
```

这表示链接脚本正确将内核加载到`0x80200000`处，内核已经成功从`OpenSBI`处接管控制权。

**练习2问题答案：**

1.`RISC-V`硬件加电后最初执行的几条指令位于地址`0x1000`到`0x1014`处。

2.最初执行的几条指令：

+ `auipc t0,0x0`：计算当前PC相关的地址，将 `0x1000` 存入`t0`寄存器作为基地址。

+ `addi a1,t0,32`：将`t0`加上`32`，赋值给`a1`。

+ `csrr a0,mhartid`：读取`mhartid`（当前`CPU`核心的`ID`），存入`a0`中。

+ `ld a1,32(t0)`：从内存 `0x1020` 处加载一个值到`a1`。

+ `ld t0,24(t0)`：从内存 `0x1018` 处加载`OpenSBI`的入口地址到`t0`。

+ `jr t0`：跳转到`OpenSBI`的入口地址 `0x80000000`。

完成的主要功能是获取当前`CPU`核心`ID`，准备启动参数，并且按照`RISC-V`调用约定设置参数，然后读取到`OenSBI`入口地址，跳转到其地址来执行`OpenSBI`。
