### 练习1: 加载应用程序并执行（需要编码）
do_execve函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序。你需要补充load_icode的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。

请在实验报告中简要说明你的设计实现过程。

请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

#### 设计实现过程
tf->gpr.sp = USTACKTOP：
- 根据 memlayout.h 定义，用户栈从 USTACKTOP 向下生长，栈顶初始地址为 USTACKTOP，确保用户程序能正常使用栈空间。

tf->epc = elf->e_entry：
- elf->e_entry 是 ELF 文件的链接入口地址，即应用程序编译链接后指定的起始执行地址，需将其设为用户态程序的 PC 初始值。

tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE：
- 清除 SSTATUS_SPP 位（值为 0）：表示当前特权级为用户态（SSTATUS_SPP=1 时为内核态），符合用户程序执行环境。
- 设置 SSTATUS_SPIE 位（值为 1）：允许用户态中断，sret 指令后会将 SPIE 映射到 SIE 位，启用中断响应。
- 保留原 sstatus 其他位：避免破坏内核态时的其他状态设置。

#### 用户态进程从 RUNNING 态到执行应用程序第一条指令的经过
进程调度触发：调度器（schedule 函数）选择该用户态进程，将其状态设为 RUNNING，调用proc_run函数。

页目录加载：proc_run中执行lsatp(next->pgdir)，将用户进程的页目录物理地址加载到 satp 寄存器，启用该进程的虚拟内存映射。

上下文切换：调用switch_to函数，保存当前运行进程的上下文（寄存器状态），恢复该用户进程的上下文（proc->context）。此时进程的程序计数器（ra）指向forkret函数。

恢复 trapframe：forkret函数调用forkrets(current->tf)，从进程的 trapframe 中恢复用户态寄存器值（包括之前设置的 sp、epc 等）。

特权级切换：执行sret指令，将 trapframe 中的status加载到 sstatus 寄存器，切换到用户态（SSTATUS_SPP=0），同时将epc加载到程序计数器（pc）。

执行第一条指令：pc 指向elf->e_entry（应用程序入口地址），CPU 开始执行用户态程序的第一条指令，进程正式进入用户态执行。

### 练习2: 父进程复制自己的内存空间给子进程（需要编码）
创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。

请在实验报告中简要说明你的设计实现过程。

#### 设计实现说明
按页复制：虚拟地址范围按 PGSIZE（4KB）拆分，确保内存对齐，符合 ucore 的分页管理机制。

内核虚拟地址访问：物理页无法直接访问，通过 page2kva 将 Page 结构体转换为内核虚拟地址，再用 memcpy 复制内容，避免地址访问错误。

权限继承：直接复用父进程 pte 的用户态权限（PTE_USER 相关位），确保子进程对该页的访问权限与父进程一致。

页表映射建立：通过 page_insert 将子进程的新物理页与虚拟地址绑定，完成地址空间复制。

### lab5的gdb调试
ecall:
![alt text](图片1.png)

sret:
![alt text](图片2.png)
#### 调试流程中 ecall/sret 的执行观察
1. ecall 执行链路：
    - 用户态程序（如exit.c）调用系统调用时，执行ecall指令（gdb 断点停在syscall.c:19的asm volatile处，对应 ecall 指令）。
    - 触发异常后，qemu 切换到内核态，进入kern/trap/trapentry.S的__alltraps函数（保存上下文、调用 trap函数处理系统调用）。
    - 系统调用处理完成后，进入__trapret标签处，准备执行sret返回用户态。
2. sret 执行链路：
    - gdb 断点设在_trapret的sret指令（地址0xffffffffc0200e9a），执行后特权级从内核态（S-mode）切换回用户态（U-mode）。
    - 恢复用户态寄存器（status、epc等），跳转到epc指向的用户程序地址（如exit函数后的下一条指令），用户程序继续执行。

#### qemu 处理 ecall/sret 的核心流程
处理 ecall 指令（用户态→内核态切换）
1. 指令识别与翻译 : TCG 翻译引擎在target/riscv/translate.c的translate_ecall函数中，识别ecall为 “异常触发指令”，生成宿主 CPU 可执行的中间代码（IR），语义为 “触发用户态异常”。	
2. 异常状态初始化 : 模拟 RISC-V 硬件行为，在target/riscv/excp_helper.c的riscv_cpu_do_interrupt中，设置scause寄存器为CAUSE_USER_ECALL（用户态系统调用），保存用户态epc（触发 ecall 的下一条指令地址）。	
3. 上下文切换模拟 : 保存用户态寄存器（x0-x31）到内核栈（对应SAVE_ALL宏逻辑），切换地址空间（修改satp寄存器为内核页目录），模拟 RISC-V 的特权级切换（U-mode→S-mode）。
4. 异常分发 : 调用内核态异常处理入口（__alltraps），后续流程交给 ucore 的trap函数处理系统调用。

处理 sret 指令（内核态→用户态返回）
1. 指令识别与翻译 :TCG 在target/riscv/translate.c中识别sret为 “异常返回指令”，生成 IR 语义：“恢复用户态上下文 + 特权级切换”。	
2. 上下文恢复模拟 : 在target/riscv/cpu.c的riscv_cpu_do_sret中，从内核栈读取保存的用户态 sstatus和epc，写入对应特权寄存器；将SSTATUS_SPP位设为 0（U-mode），恢复SSTATUS_SPIE（用户态中断使能）。	
3. 特权级与地址空间切换 : 模拟硬件行为，切换特权级从 S-mode→U-mode，恢复用户态页目录（修改satp寄存器），确保地址翻译正确。	
4. 程序计数器跳转 : 将 CPU 的程序计数器（PC）设为epc的值（用户态触发 ecall 前的下一条指令），完成返回。

#### qemu 源码关键模块说明
qemu 处理 RISC-V 特权指令依赖 3 个核心模块，各司其职：
1. 指令翻译模块（target/riscv/translate.c）：
    - 核心函数translate_ecall/translate_sret：解析 ecall/sret 的 opcode，生成对应语义的 TCG 中间代码（IR），描述 “异常触发” 或 “上下文恢复” 的逻辑。
    - 关键操作：区分用户态 / 内核态 ecall（通过sstatus的SPP位），确保翻译后的宿主指令符合 RISC-V 架构规范。
2. 异常处理模块（target/riscv/excp_helper.c）：
    - 核心函数riscv_cpu_do_interrupt：接收翻译后的异常触发 IR，模拟硬件的异常分发逻辑，设置scause、sepc等寄存器，调用内核异常入口。
    - 关键操作：处理异常优先级，确保 ecall 触发的异常被正确路由到系统调用处理流程。
3. CPU 状态管理模块（target/riscv/cpu.c）：
    - 核心函数riscv_cpu_do_sret/riscv_cpu_set_state：管理 CPU 特权级、寄存器状态、地址空间（satp寄存器），模拟硬件的上下文切换和特权级切换。
    - 关键操作：验证sret执行权限（仅内核态可执行），防止非法返回用户态。

#### TCG Translation（指令翻译）的核心作用与流程
qemu 是软件模拟器，无法直接执行 RISC-V 指令（目标指令），TCG是其核心翻译引擎，作用是将目标指令（如 ecall、sret）翻译成宿主 CPU（如 x86_64）可直接执行的机器码.

对 ecall/sret 的翻译流程
1. 指令解码 : 从 qemu 模拟的 RISC-V 内存中读取指令，解析 opcode（ecall 为0x73，sret 为0x10200073）和功能。	
2. 中间 IR 生成 : 将指令语义转换为 TCG IR（如 “设置 scause 寄存器”“保存 x0-x31 到栈”“修改 satp 寄存器”）。	
3. IR 优化 : 简化冗余 IR（如合并连续的寄存器读写），减少宿主 CPU 执行开销。	
4. 宿主指令生成 : 将优化后的 IR 编译为宿主 CPU 机器码（如 x86_64 的push/pop/mov指令）。	
5. 执行与状态同步 : 执行宿主指令，同步 qemu 模拟的 RISC-V CPU 状态（寄存器、内存、特权级）。
