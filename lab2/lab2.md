# 实验二：物理内存管理

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

#### 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？

### 设计实现过程概述
Best-Fit 算法的核心思想是：在分配内存时，优先选择最小的、能满足需求的空闲块，以减少大空闲块的不必要分割，从而保留更多大空闲块供后续大需求使用。其实现基于双向链表管理空闲块，并通过块的合并减少内存碎片。
### 物理内存分配与释放机制
#### 初始化（best_fit_init）
初始化空闲块管理结构：
- 初始化双向链表 free_list,用于串联所有空闲块；
- 初始化空闲页计数器 nr_free,记录系统中所有空闲页的总数。
#### 空闲块初始化（best_fit_init_memmap）
当系统新增一块连续空闲内存时，需将其加入空闲管理：
- 初始化块内每个页的属性：清除保留位（PG_reserved），引用计数设为 0，非起始页的 property（块大小）设为 0；
- 标记起始页 base 为空闲块起点：base->property = n（记录块大小），设置 PG_property 标志,表示该页是空闲块的起始页；
- 将该空闲块按物理地址从小到大的顺序插入 free_list,遍历链表找到第一个地址大于 base 的块，插入其前方；若到链表末尾则直接插入尾部；
- 更新 nr_free,增加 n。
#### 内存分配（best_fit_alloc_pages）
分配 n 个连续页的过程：
- 若空闲页总数 nr_free < n，直接返回 NULL；
- 遍历 free_list，寻找最小的、大小 >= n 的空闲块：
  - 用 min_size 记录当前找到的最小满足条件的块大小，page 记录对应块的起始页；
- 若找到目标块：
  - 将该块从 free_list 中移除；
  - 若块大小 > n（需分割）：剩余部分（从 page + n 开始）作为新空闲块，设置其 property 为剩余大小，标记 PG_property 并插回链表；
  - 更新 nr_free（减少 n），清除分配块的 PG_property 标志，返回起始页 page。
#### 内存释放（best_fit_free_pages）
释放从 base 开始的 n 个连续页，并合并相邻空闲块以减少碎片：
- 初始化释放的页：清除标志位，引用计数设为 0；
- 标记 base 为空闲块起点：base->property = n，设置 PG_property，更新 nr_free（增加 n）；
- 将释放的块按地址顺序插入 free_list（同 best_fit_init_memmap 的插入逻辑）；
- 合并相邻块：
  - 检查前向块：若前向块的结束地址（p + p->property）等于 base，则合并（前向块的 property 累加 base 的大小，移除 base 从链表）；
  - 检查后向块：若 base 的结束地址（base + base->property）等于后向块的起始地址，合并（base 的 property 累加后向块的大小，移除后向块从链表）。
 
### Best-Fit 算法的改进空间
Best-Fit 算法虽能减少大空闲块的分割，但存在效率和碎片管理的不足，可从以下方面改进：
#### 提升查找效率
现有实现需遍历整个 free_list 寻找最小满足条件的块（时间复杂度 O (n)），可优化数据结构：
- 按块大小维护有序链表或平衡树（如红黑树），通过块大小快速索引，将查找时间降至 O (log n)；
- 按块大小范围分组（如 1-4 页、5-8 页等），每组维护一个链表，缩小查找范围。
#### 减少外部碎片
Best-Fit 可能产生大量小空闲块（外部碎片），可结合：
- 压缩技术：定期移动已分配块，将分散的小空闲块合并为大连续块（需虚拟内存支持，避免地址变化影响程序）；
- 伙伴系统思想：将空闲块大小限制为 2 的幂，通过拆分和合并快速管理，减少碎片（但可能浪费部分内存）。
#### 优化合并策略
现有释放时立即合并的策略可能增加开销，可改为：
- 延迟合并：释放时不立即合并，仅在分配失败时尝试合并所有相邻块，减少频繁释放的合并成本；
- 预合并：在插入新块时，提前检查前后块是否可合并，避免后续重复遍历。

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。
