# 实验二：物理内存管理

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

### 实验中重要的知识点
#### 动态分区分配算法（Best-Fit）
实验中知识点含义

实验实现的 Best-Fit 算法是基于页帧的动态分区分配：
- 分配时：遍历空闲链表，找到 “大小≥需求页帧数n的最小空闲块”，避免大块被过早拆分；
- 分割：若空闲块大小 > n，则拆分出n页作为分配块，剩余页组成新空闲块插回链表；
- 释放时：按地址升序插入空闲链表，并合并前后相邻的空闲块（避免外部碎片）。


对应 OS 原理知识点：动态分区分配算法

OS 原理中，动态分区分配是连续内存分配的核心算法，适用于 “分配大小不固定、需连续内存” 的场景。Best-Fit 的核心思想是 “选择与需求最接近的空闲分区”，以减少大块内存的浪费，降低外部碎片产生概率。

关系与差异
- 关系：实验的 Best-Fit 实现完全遵循原理的算法逻辑（找最小适配块→分割→合并），是原理在 “页帧粒度” 下的具体应用。
- 差异：原理中的 “分区” 是 “任意大小的连续内存块”（如 1KB、5KB）；实验中的 “分区” 是 “4KB 整数倍的页块”（粒度固定），因此分区大小无需处理非页对齐的情况，逻辑更简洁。


#### 空闲块链表管理与块合并
实验中知识点含义

实验用双向链表（free_list）按地址升序维护空闲页块：
- 初始化 / 插入：新空闲块按物理地址升序插入链表（如best_fit_init_memmap中比较base < page）；
- 合并：释放块时，通过地址计算检查前块（p + p->property == base）和后块（base + base->property == p）是否连续，若连续则合并为一个大空闲块，清除被合并块的 “空闲首页” 标记（ClearPageProperty）并从链表删除。


对应 OS 原理知识点：空闲分区链管理

OS 原理中，空闲分区链是管理空闲内存的经典数据结构，通过链表记录所有空闲分区，支持按地址升序 / 降序、大小排序等方式组织。块合并（“紧凑” 的简化）是解决外部碎片的关键手段 —— 释放分区时，若相邻分区空闲则合并，形成更大的连续分区。

关系与差异
- 关系：实验的free_list是原理 “空闲分区链” 的页块级实现，块合并逻辑与原理完全一致（检查相邻空闲分区）。
- 差异：原理中的链表节点对应 “单个空闲分区”（需存储起始地址和大小）；实验的链表节点对应 “空闲页块的首页”（通过struct Page的property字段记录块大小，地址可通过页帧索引计算），无需额外存储起始地址，更贴合页帧管理场景。

#### 物理内存探测（DTB 解析）
实验中知识点含义

实验通过解析设备树（DTB）获取物理内存信息，是内存初始化的前提：
- DTB 验证：检查 DTB 头部magic（0xd00dfeed）确保合法性；
- 提取内存：遍历 DTB 的memory节点，解析reg属性（前 8 字节为内存基址，后 8 字节为大小）；
- 全局存储：将mem_base和mem_size保存到全局变量，供page_init初始化物理页帧。


对应 OS 原理知识点：物理内存探测

OS 原理中，物理内存探测是操作系统开机初始化的关键步骤—— 通过硬件提供的接口（如 BIOS、UEFI、设备树）获取物理内存的分布（基址、大小、是否可用），排除保留内存（如内核镜像、硬件设备占用），确定可管理的空闲内存范围。

关系与差异
- 关系：实验的 DTB 解析是原理 “物理内存探测” 在RISC-V 架构下的具体方式，核心目标（获取可管理内存范围）一致。
- 差异：探测方式依赖硬件架构 ——RISC-V 无 BIOS，需通过 DTB（设备树）描述硬件信息；x86 架构则通过 BIOS 中断（如int 0x15）获取内存信息；原理不涉及具体硬件接口，仅定义 “探测→获取内存范围” 的逻辑。

#### 虚拟地址与物理地址映射
实验中知识点含义

实验定义固定偏移量的虚实地址映射，是内核访问物理内存的基础：
- 偏移量：PHYSICAL_MEMORY_OFFSET = 0xFFFFFFFF40000000，即虚拟地址 = 物理地址 + 偏移量；
- 内核映射：内核物理基址0x80200000对应虚拟基址KERNBASE = 0xFFFFFFFFC0200000；
- 地址转换：通过PADDR（虚拟→物理）和KADDR（物理→虚拟）宏实现转换，如PADDR(kva) = kva - 偏移量。


对应 OS 原理知识点：地址重定位与虚拟地址空间划分

OS 原理中，地址重定位是将虚拟地址转换为物理地址的机制，虚拟地址空间通常划分为内核空间和用户空间（内核空间映射物理内存的固定区域）。核心逻辑是 “通过 MMU 将虚拟地址映射到物理地址，实现内存保护和地址隔离”。

关系与差异
- 关系：实验的固定偏移映射是原理 “地址重定位” 的简化实现（内核空间的直接映射），且符合 “内核空间映射物理内存” 的划分逻辑。
- 差异：原理的地址映射支持灵活的虚拟地址分配（如用户空间的随机映射），依赖页表动态调整；实验为简化内核初始化，采用 “固定偏移 + 直接映射”，仅覆盖内核空间，不支持用户空间的动态映射。

### 实验中没有的知识点
#### 内存交换（Swapping）与页置换算法
OS 原理中知识点含义

当物理内存不足时，OS 需通过 “内存交换” 扩展可用内存，核心是：
- 内存交换（Swapping）：将物理内存中暂时不用的页帧（如未活跃进程的页）写入磁盘交换区（Swap Space），释放物理内存给急需的进程；当被交换的页需再次使用时，从磁盘读回物理内存；
- 页置换算法：决定 “哪些页被交换到磁盘” 的策略，如 LRU（最近最少使用）、Clock（时钟算法）、OPT（最优置换，理论最优），核心目标是减少 “缺页中断” 次数，降低磁盘 I/O 开销（如 Windows 的 LRU 变种、Linux 的 Clock 算法）。

#### 用户态内存管理
OS 原理中知识点含义

OS 原理中，内存管理需同时覆盖内核态和用户态：
- 用户堆管理：用户进程通过malloc/free申请 / 释放动态内存，底层依赖操作系统提供的 “堆扩展接口”（如brk/sbrk）或 “内存映射接口”（如mmap），操作系统需维护用户进程的堆区边界和空闲块；
- 用户栈管理：用户进程的栈由操作系统在进程创建时初始化，设置栈指针（如 RISC-V 的sp），并支持栈的 “动态增长”（通过页错误触发栈扩展）；
- 核心目标：实现用户进程的内存隔离与高效动态内存使用，避免用户态直接操作物理内存。

#### 虚拟内存高级特性
OS 原理中知识点含义

虚拟内存的核心价值不仅是 “地址转换”，还包括内存复用与高效隔离：
- 页面共享：多个进程共享同一物理页帧，通过将不同进程的虚拟页映射到同一物理页实现，减少内存冗余（如多个进程加载libc时仅存一份物理页）；
- 写时复制（Copy-On-Write, COW）：进程创建（如fork）时，父子进程共享物理页帧，仅当某进程修改页时才复制物理页，避免创建进程时的大量内存复制，提升效率（如 Linux 的fork实现）。


#### 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？

### 设计实现过程概述
Best-Fit 算法的核心思想是：在分配内存时，优先选择最小的、能满足需求的空闲块，以减少大空闲块的不必要分割，从而保留更多大空闲块供后续大需求使用。其实现基于双向链表管理空闲块，并通过块的合并减少内存碎片。
### 物理内存分配与释放机制
#### 初始化（best_fit_init）
初始化空闲块管理结构：
- 初始化双向链表 free_list,用于串联所有空闲块；
- 初始化空闲页计数器 nr_free,记录系统中所有空闲页的总数。
#### 空闲块初始化（best_fit_init_memmap）
当系统新增一块连续空闲内存时，需将其加入空闲管理：
- 初始化块内每个页的属性：清除保留位（PG_reserved），引用计数设为 0，非起始页的 property（块大小）设为 0；
- 标记起始页 base 为空闲块起点：base->property = n（记录块大小），设置 PG_property 标志,表示该页是空闲块的起始页；
- 将该空闲块按物理地址从小到大的顺序插入 free_list,遍历链表找到第一个地址大于 base 的块，插入其前方；若到链表末尾则直接插入尾部；
- 更新 nr_free,增加 n。
#### 内存分配（best_fit_alloc_pages）
分配 n 个连续页的过程：
- 若空闲页总数 nr_free < n，直接返回 NULL；
- 遍历 free_list，寻找最小的、大小 >= n 的空闲块：
  - 用 min_size 记录当前找到的最小满足条件的块大小，page 记录对应块的起始页；
- 若找到目标块：
  - 将该块从 free_list 中移除；
  - 若块大小 > n（需分割）：剩余部分（从 page + n 开始）作为新空闲块，设置其 property 为剩余大小，标记 PG_property 并插回链表；
  - 更新 nr_free（减少 n），清除分配块的 PG_property 标志，返回起始页 page。
#### 内存释放（best_fit_free_pages）
释放从 base 开始的 n 个连续页，并合并相邻空闲块以减少碎片：
- 初始化释放的页：清除标志位，引用计数设为 0；
- 标记 base 为空闲块起点：base->property = n，设置 PG_property，更新 nr_free（增加 n）；
- 将释放的块按地址顺序插入 free_list（同 best_fit_init_memmap 的插入逻辑）；
- 合并相邻块：
  - 检查前向块：若前向块的结束地址（p + p->property）等于 base，则合并（前向块的 property 累加 base 的大小，移除 base 从链表）；
  - 检查后向块：若 base 的结束地址（base + base->property）等于后向块的起始地址，合并（base 的 property 累加后向块的大小，移除后向块从链表）。
 
### Best-Fit 算法的改进空间
Best-Fit 算法虽能减少大空闲块的分割，但存在效率和碎片管理的不足，可从以下方面改进：
#### 提升查找效率
现有实现需遍历整个 free_list 寻找最小满足条件的块（时间复杂度 O (n)），可优化数据结构：
- 按块大小维护有序链表或平衡树（如红黑树），通过块大小快速索引，将查找时间降至 O (log n)；
- 按块大小范围分组（如 1-4 页、5-8 页等），每组维护一个链表，缩小查找范围。
#### 减少外部碎片
Best-Fit 可能产生大量小空闲块（外部碎片），可结合：
- 压缩技术：定期移动已分配块，将分散的小空闲块合并为大连续块（需虚拟内存支持，避免地址变化影响程序）；
- 伙伴系统思想：将空闲块大小限制为 2 的幂，通过拆分和合并快速管理，减少碎片（但可能浪费部分内存）。
#### 优化合并策略
现有释放时立即合并的策略可能增加开销，可改为：
- 延迟合并：释放时不立即合并，仅在分配失败时尝试合并所有相邻块，减少频繁释放的合并成本；
- 预合并：在插入新块时，提前检查前后块是否可合并，避免后续重复遍历。

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

 - 参考[linux的slub分配算法/](http://www.ibm.com/developerworks/cn/linux/l-cn-slub/)，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。
