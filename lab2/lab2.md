# 实验二：物理内存管理

对实验报告的要求：
 - 基于markdown格式来完成，以文本方式为主
 - 填写各个基本练习中要求完成的报告内容
 - 完成实验后，请分析ucore_lab中提供的参考答案，并请在实验报告中说明你的实现与参考答案的区别
 - 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）
 - 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

### 实验中重要的知识点
#### 动态分区分配算法（Best-Fit）
实验中知识点含义

实验实现的 Best-Fit 算法是基于页帧的动态分区分配：
- 分配时：遍历空闲链表，找到 “大小≥需求页帧数n的最小空闲块”，避免大块被过早拆分；
- 分割：若空闲块大小 > n，则拆分出n页作为分配块，剩余页组成新空闲块插回链表；
- 释放时：按地址升序插入空闲链表，并合并前后相邻的空闲块（避免外部碎片）。


对应 OS 原理知识点：动态分区分配算法

OS 原理中，动态分区分配是连续内存分配的核心算法，适用于 “分配大小不固定、需连续内存” 的场景。Best-Fit 的核心思想是 “选择与需求最接近的空闲分区”，以减少大块内存的浪费，降低外部碎片产生概率。

关系与差异
- 关系：实验的 Best-Fit 实现完全遵循原理的算法逻辑（找最小适配块→分割→合并），是原理在 “页帧粒度” 下的具体应用。
- 差异：原理中的 “分区” 是 “任意大小的连续内存块”（如 1KB、5KB）；实验中的 “分区” 是 “4KB 整数倍的页块”（粒度固定），因此分区大小无需处理非页对齐的情况，逻辑更简洁。


#### 空闲块链表管理与块合并
实验中知识点含义

实验用双向链表（free_list）按地址升序维护空闲页块：
- 初始化 / 插入：新空闲块按物理地址升序插入链表（如best_fit_init_memmap中比较base < page）；
- 合并：释放块时，通过地址计算检查前块（p + p->property == base）和后块（base + base->property == p）是否连续，若连续则合并为一个大空闲块，清除被合并块的 “空闲首页” 标记（ClearPageProperty）并从链表删除。


对应 OS 原理知识点：空闲分区链管理

OS 原理中，空闲分区链是管理空闲内存的经典数据结构，通过链表记录所有空闲分区，支持按地址升序 / 降序、大小排序等方式组织。块合并（“紧凑” 的简化）是解决外部碎片的关键手段 —— 释放分区时，若相邻分区空闲则合并，形成更大的连续分区。

关系与差异
- 关系：实验的free_list是原理 “空闲分区链” 的页块级实现，块合并逻辑与原理完全一致（检查相邻空闲分区）。
- 差异：原理中的链表节点对应 “单个空闲分区”（需存储起始地址和大小）；实验的链表节点对应 “空闲页块的首页”（通过struct Page的property字段记录块大小，地址可通过页帧索引计算），无需额外存储起始地址，更贴合页帧管理场景。

#### 物理内存探测（DTB 解析）
实验中知识点含义

实验通过解析设备树（DTB）获取物理内存信息，是内存初始化的前提：
- DTB 验证：检查 DTB 头部magic（0xd00dfeed）确保合法性；
- 提取内存：遍历 DTB 的memory节点，解析reg属性（前 8 字节为内存基址，后 8 字节为大小）；
- 全局存储：将mem_base和mem_size保存到全局变量，供page_init初始化物理页帧。


对应 OS 原理知识点：物理内存探测

OS 原理中，物理内存探测是操作系统开机初始化的关键步骤—— 通过硬件提供的接口（如 BIOS、UEFI、设备树）获取物理内存的分布（基址、大小、是否可用），排除保留内存（如内核镜像、硬件设备占用），确定可管理的空闲内存范围。

关系与差异
- 关系：实验的 DTB 解析是原理 “物理内存探测” 在RISC-V 架构下的具体方式，核心目标（获取可管理内存范围）一致。
- 差异：探测方式依赖硬件架构 ——RISC-V 无 BIOS，需通过 DTB（设备树）描述硬件信息；x86 架构则通过 BIOS 中断（如int 0x15）获取内存信息；原理不涉及具体硬件接口，仅定义 “探测→获取内存范围” 的逻辑。

#### 虚拟地址与物理地址映射
实验中知识点含义

实验定义固定偏移量的虚实地址映射，是内核访问物理内存的基础：
- 偏移量：PHYSICAL_MEMORY_OFFSET = 0xFFFFFFFF40000000，即虚拟地址 = 物理地址 + 偏移量；
- 内核映射：内核物理基址0x80200000对应虚拟基址KERNBASE = 0xFFFFFFFFC0200000；
- 地址转换：通过PADDR（虚拟→物理）和KADDR（物理→虚拟）宏实现转换，如PADDR(kva) = kva - 偏移量。


对应 OS 原理知识点：地址重定位与虚拟地址空间划分

OS 原理中，地址重定位是将虚拟地址转换为物理地址的机制，虚拟地址空间通常划分为内核空间和用户空间（内核空间映射物理内存的固定区域）。核心逻辑是 “通过 MMU 将虚拟地址映射到物理地址，实现内存保护和地址隔离”。

关系与差异
- 关系：实验的固定偏移映射是原理 “地址重定位” 的简化实现（内核空间的直接映射），且符合 “内核空间映射物理内存” 的划分逻辑。
- 差异：原理的地址映射支持灵活的虚拟地址分配（如用户空间的随机映射），依赖页表动态调整；实验为简化内核初始化，采用 “固定偏移 + 直接映射”，仅覆盖内核空间，不支持用户空间的动态映射。

### 实验中没有的知识点
#### 内存交换（Swapping）与页置换算法
OS 原理中知识点含义

当物理内存不足时，OS 需通过 “内存交换” 扩展可用内存，核心是：
- 内存交换（Swapping）：将物理内存中暂时不用的页帧（如未活跃进程的页）写入磁盘交换区（Swap Space），释放物理内存给急需的进程；当被交换的页需再次使用时，从磁盘读回物理内存；
- 页置换算法：决定 “哪些页被交换到磁盘” 的策略，如 LRU（最近最少使用）、Clock（时钟算法）、OPT（最优置换，理论最优），核心目标是减少 “缺页中断” 次数，降低磁盘 I/O 开销（如 Windows 的 LRU 变种、Linux 的 Clock 算法）。

#### 用户态内存管理
OS 原理中知识点含义

OS 原理中，内存管理需同时覆盖内核态和用户态：
- 用户堆管理：用户进程通过malloc/free申请 / 释放动态内存，底层依赖操作系统提供的 “堆扩展接口”（如brk/sbrk）或 “内存映射接口”（如mmap），操作系统需维护用户进程的堆区边界和空闲块；
- 用户栈管理：用户进程的栈由操作系统在进程创建时初始化，设置栈指针（如 RISC-V 的sp），并支持栈的 “动态增长”（通过页错误触发栈扩展）；
- 核心目标：实现用户进程的内存隔离与高效动态内存使用，避免用户态直接操作物理内存。

#### 虚拟内存高级特性
OS 原理中知识点含义

虚拟内存的核心价值不仅是 “地址转换”，还包括内存复用与高效隔离：
- 页面共享：多个进程共享同一物理页帧，通过将不同进程的虚拟页映射到同一物理页实现，减少内存冗余（如多个进程加载libc时仅存一份物理页）；
- 写时复制（Copy-On-Write, COW）：进程创建（如fork）时，父子进程共享物理页帧，仅当某进程修改页时才复制物理页，避免创建进程时的大量内存复制，提升效率（如 Linux 的fork实现）。


#### 练习1：理解first-fit 连续物理内存分配算法（思考题）
first-fit 连续物理内存分配算法作为物理内存分配一个很基础的方法，需要同学们理解它的实现过程。请大家仔细阅读实验手册的教程并结合`kern/mm/default_pmm.c`中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。
请在实验报告中简要说明你的设计实现过程。请回答如下问题：
- 你的first fit算法是否有进一步的改进空间？

### 各个函数的作用
#### default_init 函数
作用：初始化物理内存管理的核心数据结构，为内存分配和释放提供基础。
- list_init(&free_list)：初始化空闲块双向链表（free_list 为链表头），用于串联所有空闲物理页块。
- nr_free = 0：初始化系统空闲页计数器（nr_free），记录当前系统中所有空闲物理页的总数，初始为 0（尚未有空闲页被管理）。
#### default_init_memmap 函数
作用：将一块连续的物理内存页（从 base 开始，共 n 页）初始化为空闲块，并按物理地址顺序插入空闲链表，纳入内存管理。
- 遍历初始化：对 base 到 base + n 的每一页，清除预留标志（PageReserved）、重置属性（property）和引用计数（ref），标记为可管理的空闲页。
- 标记空闲块起始页：base->property = n 记录当前空闲块的总页数，SetPageProperty(base) 标记 base 为空闲块的起始页（用于后续识别块边界）。
- 更新空闲页总数：nr_free += n 累加系统空闲页数量。
- 插入空闲链表：按物理地址从小到大的顺序将空闲块插入 free_list（确保链表中块的地址有序，便于后续分配和合并）。
#### default_alloc_pages 函数
作用：实现首次适应（First-Fit）分配策略，从空闲链表中分配 n 个连续物理页。
- 有效性检查：assert(n > 0) 确保分配页数为正数；若 n > nr_free（需求超过总空闲页），返回 NULL 表示分配失败。
- 查找空闲块：遍历 free_list，找到第一个大小 ≥ n 的空闲块（First-Fit 核心：首次满足即停止）。
- 分割与分配：若找到目标块，将其从链表中移除；若块大小 > n，分割出 n 页分配，剩余部分作为新空闲块插回链表（保持地址有序）。
- 更新状态：nr_free -= n 减少空闲页总数，ClearPageProperty(page) 清除分配块的 “空闲起始页” 标记，返回分配块的起始页 page。
#### default_free_pages 函数
作用：释放 n 个连续物理页（从 base 开始），将其标记为空闲块并插入链表，同时合并相邻空闲块以减少内存碎片。
重置释放页：遍历释放的每一页，清除已分配标志和引用计数，标记为待回收的空闲页。
- 标记空闲块：base->property = n 记录释放块大小，SetPageProperty(base) 标记为空闲起始页，nr_free += n 增加空闲页总数。
- 插入空闲链表：按物理地址顺序将释放块插入 free_list（同 default_init_memmap 的插入逻辑）。
合并相邻块：
- 前向合并：检查释放块的前一个空闲块是否与其物理连续（前块结束地址 = 释放块起始地址），若连续则合并为一个大空闲块。
- 后向合并：检查释放块的后一个空闲块是否与其物理连续（释放块结束地址 = 后块起始地址），若连续则合并为一个大空闲块。

### 物理内存分配过程
当系统需要分配 n 个连续物理页时，流程如下：
- 调用 default_alloc_pages(n)，首先检查总空闲页是否满足需求（n ≤ nr_free），不满足则返回 NULL。
- 遍历空闲链表 free_list（从链表头开始），寻找第一个大小 ≥ n 的空闲块（首次适应策略）。
- 找到目标块后，将其从链表中移除；若块大小 > n，分割出 n 页作为分配结果，剩余部分作为新空闲块插回链表（保持地址有序）。
- 更新系统空闲页总数（nr_free -= n），清除分配块的 “空闲” 标记，返回分配块的起始页。

### First-Fit 算法的改进空间
First-Fit 算法的核心优势是实现简单、分配速度快（平均无需遍历整个链表），但存在以下缺点，可进一步改进：
#### 减少低地址碎片
问题：由于总是从低地址开始查找空闲块，低地址区域容易因频繁分配 / 释放产生大量小碎片（外部碎片），导致后续大内存块分配失败。

改进：
- 采用循环首次适应（Next-Fit）：从上一次分配的位置开始查找，而非每次从链表头开始，避免低地址区域过度碎片化。
#### 提高分配效率
问题：分配时需线性遍历链表查找空闲块，当空闲块数量较多时，遍历效率低（时间复杂度 O (n)）。

改进：
- 引入分层 / 分区管理：按空闲块大小（如 1-4 页、5-8 页等）维护多个链表，分配时仅遍历对应大小的链表，减少遍历范围。
- 使用更高效的数据结构：如平衡树（红黑树）或索引表，按块大小或地址索引空闲块，将查找时间复杂度降至 O (log n)。
#### 优化碎片管理
问题：虽然释放时会合并相邻块，但仍可能存在分散的小碎片（尤其在频繁分配 / 释放不同大小块的场景）。

改进：
- 引入碎片压缩：定期将已分配块移动到连续区域，集中分散的小空闲块为大块（需虚拟内存支持，避免地址变化影响程序）。
- 预合并策略：在分配失败时触发全局碎片合并（遍历所有空闲块，合并所有连续块），而非仅在释放时合并相邻块。

#### 练习2：实现 Best-Fit 连续物理内存分配算法（需要编程）
在完成练习一后，参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。
请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放，并回答如下问题：
- 你的 Best-Fit 算法是否有进一步的改进空间？

### 设计实现过程概述
Best-Fit 算法的核心思想是：在分配内存时，优先选择最小的、能满足需求的空闲块，以减少大空闲块的不必要分割，从而保留更多大空闲块供后续大需求使用。其实现基于双向链表管理空闲块，并通过块的合并减少内存碎片。
### 物理内存分配与释放机制
#### 初始化（best_fit_init）
初始化空闲块管理结构：
- 初始化双向链表 free_list,用于串联所有空闲块；
- 初始化空闲页计数器 nr_free,记录系统中所有空闲页的总数。
#### 空闲块初始化（best_fit_init_memmap）
当系统新增一块连续空闲内存时，需将其加入空闲管理：
- 初始化块内每个页的属性：清除保留位（PG_reserved），引用计数设为 0，非起始页的 property（块大小）设为 0；
- 标记起始页 base 为空闲块起点：base->property = n（记录块大小），设置 PG_property 标志,表示该页是空闲块的起始页；
- 将该空闲块按物理地址从小到大的顺序插入 free_list,遍历链表找到第一个地址大于 base 的块，插入其前方；若到链表末尾则直接插入尾部；
- 更新 nr_free,增加 n。
#### 内存分配（best_fit_alloc_pages）
分配 n 个连续页的过程：
- 若空闲页总数 nr_free < n，直接返回 NULL；
- 遍历 free_list，寻找最小的、大小 >= n 的空闲块：
  - 用 min_size 记录当前找到的最小满足条件的块大小，page 记录对应块的起始页；
- 若找到目标块：
  - 将该块从 free_list 中移除；
  - 若块大小 > n（需分割）：剩余部分（从 page + n 开始）作为新空闲块，设置其 property 为剩余大小，标记 PG_property 并插回链表；
  - 更新 nr_free（减少 n），清除分配块的 PG_property 标志，返回起始页 page。
#### 内存释放（best_fit_free_pages）
释放从 base 开始的 n 个连续页，并合并相邻空闲块以减少碎片：
- 初始化释放的页：清除标志位，引用计数设为 0；
- 标记 base 为空闲块起点：base->property = n，设置 PG_property，更新 nr_free（增加 n）；
- 将释放的块按地址顺序插入 free_list（同 best_fit_init_memmap 的插入逻辑）；
- 合并相邻块：
  - 检查前向块：若前向块的结束地址（p + p->property）等于 base，则合并（前向块的 property 累加 base 的大小，移除 base 从链表）；
  - 检查后向块：若 base 的结束地址（base + base->property）等于后向块的起始地址，合并（base 的 property 累加后向块的大小，移除后向块从链表）。
 
### Best-Fit 算法的改进空间
Best-Fit 算法虽能减少大空闲块的分割，但存在效率和碎片管理的不足，可从以下方面改进：
#### 提升查找效率
现有实现需遍历整个 free_list 寻找最小满足条件的块（时间复杂度 O (n)），可优化数据结构：
- 按块大小维护有序链表或平衡树（如红黑树），通过块大小快速索引，将查找时间降至 O (log n)；
- 按块大小范围分组（如 1-4 页、5-8 页等），每组维护一个链表，缩小查找范围。
#### 减少外部碎片
Best-Fit 可能产生大量小空闲块（外部碎片），可结合：
- 压缩技术：定期移动已分配块，将分散的小空闲块合并为大连续块（需虚拟内存支持，避免地址变化影响程序）；
- 伙伴系统思想：将空闲块大小限制为 2 的幂，通过拆分和合并快速管理，减少碎片（但可能浪费部分内存）。
#### 优化合并策略
现有释放时立即合并的策略可能增加开销，可改为：
- 延迟合并：释放时不立即合并，仅在分配失败时尝试合并所有相邻块，减少频繁释放的合并成本；
- 预合并：在插入新块时，提前检查前后块是否可合并，避免后续重复遍历。

#### 扩展练习Challenge：buddy system（伙伴系统）分配算法（需要编程）

Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128...

 -  参考[伙伴分配器的一个极简实现](http://coolshell.cn/articles/10427.html)， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。
 
#### 扩展练习Challenge：任意大小的内存单元slub分配算法（需要编程）

### SLUB 核心思想
**采用两级内存管理架构**，底层使用页分配器进行整页分配，上层在页内**构建对象缓存**，将每个页划分为多个固定大小的对象并通过位图跟踪分配状态，从而实现小内存对象的快速分配和释放，同时通过整页回收机制避免内存碎片。

### 缓存（Caches）
`SLUB` 为**每种大小的内存对象维护一个缓存（cache）**，每个缓存对应一种特定大小的对象，管理着这些对象的分配和释放。其中**每个缓存管理一些slab**，形成slab链表，并且cache中的对象大小固定，可以减少内存碎片并提高分配效率。

### Slab管理
一个 slab 是**一块连续的内存区域**，本实验中我们以页为单位来构造slab，其中包含多个相同大小的对象，并且每个 slab 都与一个特定的cache相关联。
在状态管理方面，每个 slab 可以处于三种状态之一：
- **完全空闲**：所有对象都未被分配。
- **部分分配**：部分对象已被分配，部分对象仍然空闲。
- **完全分配**：所有对象都已被分配。

### 对象的分配和释放
分配对象：
- 当需要分配一个对象时，`SLUB` 会在对应缓存的 slabs 中寻找第一个有空闲对象的 slab。
- 如果找到一个部分分配的 slab，`SLUB` 会分配一个空闲对象并更新 slab 的状态。
- 如果没有找到合适的 slab，`SLUB` 会创建一个新的 slab 并分配对象。
释放对象：
- 当释放一个对象时，`SLUB` 会将其返回到所属的 slab，并更新 slab 的状态。
- 如果一个 slab 中所有对象都被释放，`SLUB` 可以将该 slab 返回给内存池以供重用。

### 设计实现

#### 1.设计思路
我们实现的 SLUB 算法采用**两层架构**的高效内存单元分配：
- **第一层**：基于页大小的内存分配，使用 Best-Fit 算法作为底层页分配策略
- **第二层**：在第一层基础上实现基于任意大小的内存分配，专门处理小内存请求
##### **核心设计**：
- 小内存需求（≤128B）由 SLUB 管理，大内存需求（>128B）回退到页分配器
- 每个 slab 占用一个物理页（4KB），内存布局精心设计
- 使用位图高效跟踪对象分配状态

#### 2. 内存布局设计
每个 slab 页面的内存布局如下：
```
[slab头][对象0][对象1]...[对象N][位图]
```
**详细结构**：
- **slab头**：`slab_t` 结构体，管理 slab 元数据
- **对象数组**：连续存储的固定大小对象
- **位图**：每个位对应一个对象的分配状态（0=空闲，1=已分配）

#### 3. 核心数据结构
##### Slab 结构
```c
typedef struct slab {
    list_entry_t list_link;     // 链接到缓存中的 slab 列表
    void *objects;              // 对象数组起始地址
    unsigned char *bitmap;      // 对象分配位图
    size_t free_objects;        // 空闲对象数量
    size_t total_objects;       // 总对象数量
    struct cache *cache;        // 所属缓存
} slab_t;
```
##### Cache 结构
```c
typedef struct cache {
    list_entry_t slabs_full;    // 全满的 slab 列表
    list_entry_t slabs_partial; // 部分分配的 slab 列表  
    list_entry_t slabs_free;    // 完全空闲的 slab 列表
    size_t object_size;         // 对象大小
    size_t objects_per_slab;    // 每个 slab 的对象数量
    const char *name;           // 缓存名称
} cache_t;
```

#### 4. 初始化机制
##### 两层初始化架构:
**第一层**：页分配器初始化
- 使用 Best-Fit 算法初始化物理页管理
- 建立完整的物理内存管理框架
**第二层**：SLUB 缓存初始化
```c
static cache_t slub_caches[SLAB_CACHE_NUM];  // 3个固定大小缓存
void slub_init(void) {
    size_t sizes[SLAB_CACHE_NUM] = {32, 64, 128};
    const char *names[SLAB_CACHE_NUM] = {"size-32", "size-64", "size-128"};
    
    for (int i = 0; i < SLAB_CACHE_NUM; i++) {
        // 初始化每个缓存
        cache_init(&slub_caches[i], sizes[i], names[i]);
    }
}
```
##### 对象数量计算算法:
通过求解不等式计算每个 slab 能容纳的最大对象数：
```c
slab_struct_size + x * object_size + ceil(x/8) ≤ 4096
```
**计算结果**：
- 32B 对象：125个/slab
- 64B 对象：63个/slab
- 128B 对象：31个/slab

#### 5. 分配算法
##### 分配流程
```c
void *slub_alloc(size_t size) {
    // 1. 延迟初始化检查
    if (!slub_initialized) slub_init();
    // 2. 大对象回退检查
    if (size > 128) return slub_alloc_pages(...);
    // 3. 查找合适缓存
    cache_t *target_cache = find_suitable_cache(size);
    // 4. 三级查找策略
    slab_t *slab = NULL;
    if (!list_empty(&target_cache->slabs_partial)) {
        // 优先使用部分分配的slab
        slab = get_from_partial_list(target_cache);
    } else if (!list_empty(&target_cache->slabs_free)) {
        // 其次使用空闲slab
        slab = get_from_free_list(target_cache);
    } else {
        // 最后创建新slab
        slab = slab_create(target_cache);
    }
    // 5. 在位图中查找空闲对象
    for (每个对象位置) {
        if (位图显示空闲) {
            设置位图标记；
            更新空闲计数；
            返回对象地址；
        }
    }
}
```
##### 三级查找策略
1. **部分分配slab优先**：最高效，直接分配空闲对象
2. **空闲slab次之**：需要移动到部分分配列表
3. **创建新slab**：最后手段，分配新物理页

#### 6. 释放算法
##### 释放流程
```c
void slub_free(void *obj) {
    // 1. 找到对象所属的slab
    struct Page *page = pa2page(PADDR(obj));
    slab_t *slab = (slab_t *)page2kva(page);
    // 2. 计算对象索引
    offset = obj - slab->objects;
    index = offset / object_size;
    // 3. 更新位图和计数
    slab->bitmap[index] = 0;  // 标记为空闲
    slab->free_objects++;
    // 4. 状态转移处理
    list_del(&slab->list_link);
    if (slab->free_objects == slab->total_objects) {
        // 完全空闲 → 移动到空闲列表
        list_add(&cache->slabs_free, &slab->list_link);
    } else {
        // 保持部分分配状态
        list_add(&cache->slabs_partial, &slab->list_link);
    }
}
```

#### 7. 状态管理机制
##### Slab 状态转移图
```
完全空闲 (slabs_free)
    ↑↓ 分配/释放对象
部分分配 (slabs_partial) 
    ↑↓ 分配所有对象/释放到全空
完全占用 (slabs_full)
```
##### 状态转换规则
**分配时**：
- 空闲 → 部分分配（首次分配）
- 部分分配 → 完全占用（分配最后一个对象）
**释放时**：
- 完全占用 → 部分分配（释放一个对象）
- 部分分配 → 完全空闲（释放到全空）

### 测试部分
我们针对SLUB算法的功能进行了**精简测试**，测试主要覆盖以下四个方面：
- 基本分配释放功能
- 内存重用机制
- 大对象回退机制
- 多对象管理和数据完整性
具体测试代码与测试结果见slum_pmm.c最后部分以及终端运行结果。

#### 扩展练习Challenge：硬件的可用物理内存范围的获取方法（思考题）
  - 如果 OS 无法提前知道当前硬件的可用物理内存范围，请问你有何办法让 OS 获取可用物理内存范围？


操作系统获取可用物理内存范围的核心思路是通过固件支持、引导程序传递、主动硬件探测等方式，逐步识别可访问的物理地址空间。具体方法如下：
#### 依赖固件提供的内存映射服务
现代计算机启动时，固件（BIOS 或 UEFI）会先于操作系统完成硬件初始化，包括内存探测。操作系统可通过调用固件提供的标准接口，直接获取内存范围及类型。
- BIOS 环境：通过中断服务（如 x86 的INT 15h, E820h功能）获取内存映射。该接口返回一系列内存块描述符，包含起始地址、长度、类型，OS 可筛选出 “可用” 类型的块。
- UEFI 环境：通过 UEFI 规范定义的GetMemoryMap()函数获取内存描述符列表。相比 BIOS，UEFI 的内存映射更准确，支持 64 位地址空间，且明确区分各类内存。

#### 由引导加载程序预先探测并传递信息
若固件未提供直接接口（如嵌入式系统），引导程序（如 GRUB、U-Boot）可在 OS 启动前完成内存探测，再将结果传递给 OS。
- 引导程序通过硬件手册定义的内存控制器寄存器读取内存总容量，或通过 “读写验证”（向地址写入已知值并读回校验）识别可用范围。
- 传递方式：通过约定的数据结构（如 Linux 的boot_params、ARM 的设备树 Device Tree）将内存范围告知 OS。

#### 操作系统主动进行内存探测
若完全无外部信息，OS 需自行探测，核心逻辑是通过读写验证识别可访问的物理地址，步骤如下：
- 起始点：从已知的安全地址开始（如 CPU 复位后的初始执行地址附近，通常为低地址 RAM）。
- 逐步扩展：向更高地址写入特定测试值，立即读回校验。若读写一致，标记为 “潜在可用”；若读写失败（如触发总线错误），标记为 “不可用”。
- 规避风险：需预先排除已知的保留区域（如硬件寄存器地址、BIOS ROM 地址，可通过硬件手册确认），避免向设备寄存器写入数据导致硬件异常。
- 类型区分：对探测到的 “可用” 地址，进一步通过是否支持缓存、是否可被 CPU 直接访问等特性，区分常规 RAM 与特殊内存。


> Challenges是选做，完成Challenge的同学可单独提交Challenge。完成得好的同学可获得最终考试成绩的加分。
